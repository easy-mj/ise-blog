---
title: 架构基础知识
categories:
  - 前端架构
tags:
  - 前端架构
author:
  name: MJ
  link: https://github.com/easy-mj/ise-blog
---

# 1. 软件设计原则

## 1.1 单一职责原则

单一职责原则（Single Responsibility Principle，SRP）指的是一个类或者函数应该只有一个引起它变化的原因，也就是只负责一项职责。

应用：如果一个类或者方法拥有了两种职责，那么就应该将这个类或者方法分成两个类或方法

案例：基于 JavaScript 开发一个简单的博客系统

```js
// 模拟从服务器获取博客文章列表的函数（这里使用模拟数据代替实际的API请求）
function getBlogPosts() {
  return [
    { id: 1, title: "第一篇文章", content: "这是第一篇文章的内容" },
    { id: 2, title: "第二篇文章", content: "这是第二篇文章的内容" },
  ];
}

// 格式化博客文章的函数，将文章内容截断为固定长度并添加省略号
function formatBlogPost(post) {
  const maxLength = 50;
  if (post.content.length > maxLength) {
    post.content = post.content.slice(0, maxLength) + "...";
  }
  return post;
}

// 在页面上渲染博客文章列表的函数
function renderBlogPosts(posts) {
  const blogList = document.createElement("ul");
  posts.forEach((post) => {
    const listItem = document.createElement("li");
    listItem.innerHTML = `<h3>${post.title}</h3><p>${post.content}</p>`;
    blogList.appendChild(listItem);
  });
  document.body.appendChild(blogList);
}

// 主函数，协调各个功能函数的执行
function displayBlogPosts() {
  const posts = getBlogPosts();
  const formattedPosts = posts.map(formatBlogPost);
  renderBlogPosts(formattedPosts);
}

// 调用主函数来显示博客文章列表
displayBlogPosts();
```

在这个案例中：

- `getBlogPosts` 函数负责获取博客文章列表，不涉及其他功能。
- `formatBlogPost` 函数专门用于格式化单个博客文章的显示内容。
- `renderBlogPosts` 函数只负责将博客文章列表渲染到页面上。
- `displayBlogPosts` 函数作为协调者，调用上述三个函数来完成整个博客文章的获取、格式化和渲染流程。

## 1.2 开放封闭原则

开放封闭原则（Open - Closed Principle，OCP）是面向对象编程中的一个重要设计原则，它指出软件实体（类、模块、函数等）应该对扩展开放，对修改封闭。也就是说，在不修改现有代码的基础上，能够通过扩展来添加新功能。

应用：当需求有改动，尽量用继承或组合的方式来扩展实体（类、模块、函数等）的功能，而不是直接修改实体（类、模块、函数等）的代码。

案例：JavaScript 实现图形绘制系统

```js
// 图形基类
class Shape {
  draw() {
    throw new Error("抽象方法，子类必须实现");
  }
}

// 圆形类
class Circle extends Shape {
  constructor(radius) {
    super();
    this.radius = radius;
  }

  draw() {
    console.log(`绘制圆形，半径为 ${this.radius}`);
  }
}

// 矩形类
class Rectangle extends Shape {
  constructor(width, height) {
    super();
    this.width = width;
    this.height = height;
  }

  draw() {
    console.log(`绘制矩形，宽为 ${this.width}，高为 ${this.height}`);
  }
}

// 图形绘制器
class ShapeDrawer {
  drawShapes(shapes) {
    shapes.forEach((shape) => shape.draw());
  }
}
```

现在，如果我们要添加绘制三角形的功能，按照开放封闭原则，我们不应该修改现有的 Shape 类、ShapeDrawer 类等，而是通过扩展来实现。

```js
// 三角形类
class Triangle extends Shape {
  constructor(base, height) {
    super();
    this.base = base;
    this.height = height;
  }

  draw() {
    console.log(`绘制三角形，底为 ${this.base}，高为 ${this.height}`);
  }
}
```

使用时

```js
// 创建一些图形对象
const circle = new Circle(5);
const rectangle = new Rectangle(4, 6);
const triangle = new Triangle(3, 8);

// 将图形对象放入数组
const shapes = [circle, rectangle, triangle];

// 创建图形绘制器并绘制图形
const shapeDrawer = new ShapeDrawer();
shapeDrawer.drawShapes(shapes);
```

在这个案例中，`Shape` 类是所有图形的基类，它定义了一个抽象的 `draw` 方法。`Circle`、`Rectangle` 和 `Triangle` 类都是 `Shape` 类的子类，它们各自实现了 `draw` 方法来绘制具体的图形。`ShapeDrawer` 类负责绘制一组图形，它通过调用每个图形对象的 `draw` 方法来实现。当需要添加新的图形（如三角形）时，我们只需要增加一个新的子类 `Triangle`，而不需要修改现有的 `Shape` 类、`ShapeDrawer` 类等，满足开放封闭原则。这样的设计使得代码具有更好的可维护性和可扩展性。

## 1.3 里氏替换原则

里氏替换原则（Liskov Substitution Principle，LSP）是面向对象编程中的一个重要原则，它指出子类对象必须能够替换掉它们的父类对象，而程序的行为不会因此发生改变。也就是说，在任何使用父类的地方，都应该可以透明地使用子类，而不会出现错误或异常的行为。

案例：

```js
// 定义一个鸟类的基类
class Bird {
  fly() {
    console.log("鸟在飞翔");
  }
}

// 定义一个具体的鸟类 - 麻雀类，继承自鸟类
class Sparrow extends Bird {
  // 麻雀会飞，这里可以重写父类的fly方法，也可以直接继承父类的fly方法
  fly() {
    super.fly();
  }
}

// 定义一个鸵鸟类，也是鸟类的一种，但鸵鸟不会飞
class Ostrich extends Bird {
  // 这里不能简单地重写父类的fly方法，因为鸵鸟不会飞，如果重写可能会导致不符合里氏替换原则
  // 可以选择抛出异常或者采用其他合适的处理方式
  fly() {
    throw new Error("鸵鸟不会飞，不能调用fly方法");
  }
}

// 定义一个函数，用于让鸟飞翔，这里传入的参数是鸟类的实例
function makeBirdFly(bird) {
  bird.fly();
}

// 创建麻雀和鸵鸟的实例
const sparrow = new Sparrow();
const ostrich = new Ostrich();

// 让麻雀飞翔，符合里氏替换原则，行为正常
makeBirdFly(sparrow);

// 让鸵鸟飞翔，会抛出异常，不符合里氏替换原则，因为在这个场景下，鸵鸟不能像其他会飞的鸟一样被替换使用
try {
  makeBirdFly(ostrich);
} catch (error) {
  console.error(error.message);
}
```

在这个案例中，`Bird`是基类，`Sparrow`是`Bird`的子类，它重写了`fly`方法来实现自己的飞翔行为，由于麻雀会飞，所以在使用`makeBirdFly`函数时，将`Sparrow`的实例作为参数传入，能够正常工作，符合里氏替换原则。而`Ostrich`也是`Bird`的子类，但鸵鸟实际上不会飞，在`Ostrich`类中如果简单地重写`fly`方法来模拟飞翔，就不符合实际情况，也违反了里氏替换原则。这里采用抛出异常的方式来提示错误，表明鸵鸟不能像其他会飞的鸟一样被替换使用。

如果要符合里氏替换原则，可以考虑将`Bird`类中的`fly`方法提取到一个接口（在 JavaScript 中可以用抽象类或约定来模拟接口）中，只让会飞的鸟类实现这个接口，而鸵鸟类不实现这个接口，这样就可以更清晰地表达不同鸟类的行为差异，避免违反里氏替换原则。以下是修改后的代码：

```js
// 定义一个飞行接口（用抽象类模拟）
class Flyable {
  fly() {
    throw new Error("抽象方法，子类必须实现");
  }
}

// 定义一个鸟类的基类，不再包含fly方法
class Bird {
  // 其他鸟类共有的属性和方法
}

// 定义一个具体的鸟类 - 麻雀类，继承自鸟类并实现飞行接口
class Sparrow extends Bird implements Flyable {
  fly() {
    console.log("麻雀在飞翔");
  }
}

// 定义一个鸵鸟类，继承自鸟类，但不实现飞行接口，因为鸵鸟不会飞
class Ostrich extends Bird {
  // 鸵鸟特有的属性和方法
}

// 定义一个函数，用于让会飞的鸟飞翔，这里传入的参数是实现了Flyable接口的实例
function makeFlyableBirdFly(flyableBird) {
  flyableBird.fly();
}

// 创建麻雀和鸵鸟的实例
const sparrow = new Sparrow();
const ostrich = new Ostrich();

// 让麻雀飞翔，符合里氏替换原则，行为正常
makeFlyableBirdFly(sparrow);

// 尝试让鸵鸟飞翔，会报错，因为鸵鸟没有实现Flyable接口，不能传入makeFlyableBirdFly函数
// 这样就更清晰地体现了不同鸟类的行为差异，符合里氏替换原则
try {
  makeFlyableBirdFly(ostrich);
} catch (error) {
  console.error("鸵鸟不会飞，不能调用makeFlyableBirdFly函数");
}
```

通过这种方式，明确了不同鸟类的行为规范，使得代码更符合里氏替换原则，提高了代码的可维护性和可扩展性。当需要添加其他会飞或不会飞的鸟类时，可以按照相应的规则进行扩展，而不会影响到现有的代码逻辑。

## 1.4 最少知识原则

最少知识原则（Least Knowledge Principle，LKP），也叫迪米特法则（Law of Demeter），其核心思想是一个对象应该对其他对象有尽可能少的了解，只与直接的朋友通信，减少对象之间的耦合度，提高系统的可维护性和可扩展性。

高内聚，低耦合。

应用：做系统设计时，尽量减少依赖关系。

案例：

```js
// 定义一个学校类
class School {
  constructor() {
    this.students = [];
  }

  addStudent(student) {
    this.students.push(student);
  }

  // 学校组织活动，让所有学生参加
  organizeActivity() {
    this.students.forEach((student) => student.participateInActivity());
  }
}

// 定义一个学生类
class Student {
  constructor(name) {
    this.name = name;
  }

  // 学生参加活动的方法
  participateInActivity() {
    console.log(`${this.name} 参加了学校活动`);
  }
}

// 使用示例
const school = new School();
const student1 = new Student("张三");
const student2 = new Student("李四");

school.addStudent(student1);
school.addStudent(student2);

school.organizeActivity();
```

在上述代码中，`School`类和`Student`类是直接的朋友关系。`School`类只需要知道`Student`类有一个`participateInActivity`方法，就可以让学生参加活动，而不需要了解`Student`类的其他细节。同样，`Student`类只需要知道自己要参加活动，而不需要了解学校组织活动的具体过程。这样，两个类之间的耦合度较低，符合最少知识原则。

如果违反最少知识原则，可能会出现以下情况，例如在 `School` 类中直接访问 `Student` 类的其他非必要方法或属性，或者 `Student` 类过多地依赖于 `School` 类的内部实现，这都会导致代码的可维护性和可扩展性变差。当其中一个类的内部实现发生变化时，可能会影响到其他与之紧密耦合的类，增加了系统的复杂性和出错的概率。

## 1.5 接口隔离原则

接口隔离原则（Interface Segregation Principle，ISP）是指客户端不应该依赖它不需要的接口，一个类对另一个类的依赖应该建立在最小的接口上。其目的是将臃肿庞大的接口拆分成更小、更具体的接口，让不同的客户端只依赖它们实际需要的接口方法，从而降低接口的复杂度，提高系统的可维护性和可扩展性。

理解：不要对外暴露没有实际意义的接口，用户不应该依赖它不需要的接口。

应用：当需要对外暴露接口时，如果是非必要对外提供，尽量删除。

案例：

```js
// 定义一个动物接口，包含移动和进食的方法
const AnimalInterface = {
  move: () => {},
  eat: () => {},
};

// 鸟类实现动物接口
class Bird implements AnimalInterface {
  move() {
    console.log("鸟儿在天空中飞翔");
  }

  eat() {
    console.log("鸟儿在吃虫子");
  }
}

// 鱼类实现动物接口
class Fish implements AnimalInterface {
  move() {
    console.log("鱼儿在水中游动");
  }

  eat() {
    console.log("鱼儿在吃浮游生物");
  }
}

// 定义一个只会移动的接口
const MovableInterface = {
  move: () => {},
};

// 汽车类实现只会移动的接口
class Car implements MovableInterface {
  move() {
    console.log("汽车在公路上行驶");
  }
}
```

在上述代码中，最开始定义了一个 `AnimalInterface` 接口，包含 `move` 和 `eat` 方法，鸟类和鱼类都实现了这个接口，因为它们既需要移动也需要进食。但后来出现了 `Car` 类，它只需要移动功能，不需要进食功能，如果让 `Car` 类实现 `AnimalInterface` 接口，就会违背接口隔离原则，因为 `Car` 类依赖了它不需要的 `eat` 方法。所以，又定义了一个 `MovableInterface` 接口，只包含 `move` 方法，让 `Car` 类实现这个接口，这样就满足了接口隔离原则，每个类都只依赖它需要的接口方法。

## 1.6 依赖倒置原则

依赖倒置原则（Dependency Inversion Principle，DIP）是指高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。其核心思想是通过依赖抽象来降低模块间的耦合度，提高系统的稳定性、可维护性和可扩展性。

理解：应该面向接口编程，不应该面向实现类编程。并不是说所有的类都要有一个对应的接口，而是说如果有接口，就要尽量使用接口来编程。

案例：

```js
// 抽象的数据库连接接口
class DatabaseConnection {
  connect() {
    throw new Error("抽象方法，必须在子类中实现");
  }
  disconnect() {
    throw new Error("抽象方法，必须在子类中实现");
  }
}

// MySQL数据库连接实现
class MySQLConnection extends DatabaseConnection {
  connect() {
    console.log("连接到MySQL数据库");
  }
  disconnect() {
    console.log("断开与MySQL数据库的连接");
  }
}

// MongoDB数据库连接实现
class MongoDBConnection extends DatabaseConnection {
  connect() {
    console.log("连接到MongoDB数据库");
  }
  disconnect() {
    console.log("断开与MongoDB数据库的连接");
  }
}

// 高层模块，依赖抽象的数据库连接接口
class DatabaseUser {
  constructor(connection) {
    // 依赖注入抽象的数据库连接对象
    this.connection = connection;
  }
  useDatabase() {
    this.connection.connect();
    // 这里可以执行一些数据库操作
    console.log("使用数据库执行操作");
    this.connection.disconnect();
  }
}

// 使用示例
// 创建MySQL数据库连接对象
const mysqlConnection = new MySQLConnection();
// 创建依赖MySQL连接的DatabaseUser对象
const mysqlUser = new DatabaseUser(mysqlConnection);
mysqlUser.useDatabase();

// 创建MongoDB数据库连接对象
const mongoConnection = new MongoDBConnection();
// 创建依赖MongoDB连接的DatabaseUser对象
const mongoUser = new DatabaseUser(mongoConnection);
mongoUser.useDatabase();
```

在上述代码中，`DatabaseConnection`是一个抽象的数据库连接接口，定义了连接和断开连接的抽象方法。

`MySQLConnection`和`MongoDBConnection`是具体的数据库连接实现，它们继承自`DatabaseConnection`并实现了其抽象方法。`DatabaseUser`是高层模块，它不依赖具体的数据库连接实现，而是依赖抽象的`DatabaseConnection`接口。通过依赖注入的方式，将具体的数据库连接对象传入`DatabaseUser`中，这样高层模块就可以根据不同的需求使用不同的数据库连接，而不需要修改自身的代码。

如果不遵循依赖倒置原则，`DatabaseUser`直接依赖具体的数据库连接类，那么当需要更换数据库类型时，就需要在`DatabaseUser`类中修改代码，这会导致代码的可维护性和可扩展性变差。而通过依赖倒置，将依赖关系反转，使得高层模块和低层模块都依赖抽象，降低了模块间的耦合度，提高了系统的灵活性和可维护性。

> 总结

将以上六大原则的英文首字母拼在一起就是 `SOLID`（稳定的），所以也称之为 `SOLID` 原则。
