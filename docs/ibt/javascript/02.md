---
layout: doc
---

# 面向对象编程/原型及原型链

::: tip 知识点

- 参数按值传递
- 手写 call 和 apply
- 手写 bind
- 手写模拟 new
- 类数组对象 和 arguments
- 创建对象的多种方式 & 优缺点
- 继承的多种方式 & 优缺点

:::

::: details 目标

- 初级：掌握 JavaScript 基础使用
- 中级：掌握 JavaScript 语法的常见面试题及使用技巧
- 高级：掌握 JavaScript 的核心原理实现

:::

::: details 资料

- 官网MDN：https://developer.mozilla.org/en-US/docs/Web/JavaScript
- 画图工具🔧：https://www.processon.com/
- 豆包旗下的智能编程助手Trae AI: https://www.marscode.com/extension

:::


## 1. 参数按值传递

在《JavaScript高级程序设计》中提到传递参数：
> ECMAScript 中所有函数的参数都是按值传递的。

什么是按值传递呢？
> 按值传递指的是把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。

### 1.1 按值传递

举个简单的例子：
```js
var value = 1;
function foo(v) {
  v = 2
  console.log(v)  // 2
}
foo(value)
console.log(value)  // 1
```
上面的代码很好理解，当传递 `value` 到函数 `foo` 中的时候，相当于拷贝了一份 `value`，假设拷贝的这份叫 `_value`，函数中修改的都是 `_value` 的值，而不会影响原来的 `value` 的值。

### 1.2 共享传递

拷贝虽然很好理解，但是当值是一个复杂的数据结构的时候，拷贝会产生性能上的问题。

这里提及一种：按引用传递。

所谓按引用传递，就是传递对象的引用，函数内部对参数的任何改变都会影响到该对象的值，因为两者引用的是同一个对象。

举个例子：
```js
var obj = {
  value: 1
}
function foo(o) {
  o.value = 2
  console.log(o.value)  // 2
}
foo(obj)
console.log(obj.value)  // 2
```

为什么《JavaScript高级程序设计》中说所有函数的参数都是按值传递的，那为什么能按“引用传递”成功呢？
``` js
var obj = {
  value: 1
}
function foo(o) {
  o = 2
  console.log(o)  // 2
}
foo(obj)
console.log(obj.value)  // 1
```

如果 `JavaScript` 采用的是按引用传递，外层的值也会被修改，那这里如何解释呢？

这就要讲到第二种传递方式，叫“共享传递”。

所谓的共享传递是指，在传递对象的时候，传递的是地址索引。

所以修改 `o.value` ，可以通过引用找到原值，但是直接修改 `o` ，并不会修改原值。所以第二个和第三个例子其实都是按共享传递。

最后，你可以这样理解：

参数如果是基本类型是按值传递，如果是引用类型是按共享传递。但是因为拷贝副本也是一种值的拷贝，所以在《JavaScript高级程序设计》中也直接认为是按值传递了。换句话说，函数传递参数，传递的是参数的拷贝：
- 指针拷贝，拷贝的是地址索引
- 常规类型拷贝，拷贝的是值

所以，总共有两种传递方式：按值传递和按共享传递。

### 1.3 总结

`JavaScript` 中数据类型分为基本类型与引用类型：
- 基本类型的值存储于栈内存中，传递的就是当前值，修改不会影响原有的变量的值
- 引用类型的值其实也存于栈内存中，只是它的值是指向堆内存当中实际值的一个地址；索引引用传递，传递的是地址索引，修改会影响原有的变量的值

所以针对上述的内容：

**示例1**
``` js
var value = 1;
function foo(v) {
  v = 2
  console.log(v)  // 2
}
foo(value)
console.log(value)  // 1
```

内存分布

- 改变前：

<table>
  <tbody>
    <tr>
      <th colspan="2">栈内存</th>
      <th>堆内存</th>
    </tr>
    <tr>
      <td>value</td>
      <td>1</td>
      <td></td>
    </tr>
    <tr>
      <td>v</td>
      <td>1</td>
      <td></td>
    </tr>
  </tbody>
</table>

- 改变后：

<table>
  <tbody>
    <tr>
      <th colspan="2">栈内存</th>
      <th>堆内存</th>
    </tr>
    <tr>
      <td>value</td>
      <td>1</td>
      <td></td>
    </tr>
    <tr>
      <td>v</td>
      <td>2</td>
      <td></td>
    </tr>
  </tbody>
</table>

**示例2**

``` js
var obj = {
  value: 1
}
function foo(o) {
  o.value = 2
  console.log(o.value)  // 2
}
foo(obj)
console.log(obj.value)  // 2
```

内存分布

- 改变前：

<table>
  <tbody>
    <tr>
      <th colspan="2">栈内存</th>
      <th>堆内存</th>
    </tr>
    <tr>
      <td>obj</td>
      <td>指针地址</td>
      <td>{ value: 1 }</td>
    </tr>
    <tr>
      <td>o</td>
      <td>指针地址</td>
      <td>{ value: 1 }</td>
    </tr>
  </tbody>
</table>

- 改变后：

<table>
  <tbody>
    <tr>
      <th colspan="2">栈内存</th>
      <th>堆内存</th>
    </tr>
    <tr>
      <td>obj</td>
      <td>指针地址</td>
      <td>{ value: 2 }</td>
    </tr>
    <tr>
      <td>o</td>
      <td>指针地址</td>
      <td>{ value: 2 }</td>
    </tr>
  </tbody>
</table>

**示例3**

``` js
var obj = {
  value: 1
}
function foo(o) {
  o = 2
  console.log(o)  // 2
}
foo(obj)
console.log(obj.value)  // 1
```

内存分布

- 改变前：
<table>
  <tbody>
    <tr>
      <th colspan="2">栈内存</th>
      <th>堆内存</th>
    </tr>
    <tr>
      <td>obj</td>
      <td>指针地址</td>
      <td>{ value: 1 }</td>
    </tr>
    <tr>
      <td>o</td>
      <td>指针地址</td>
      <td>{ value: 1 }</td>
    </tr>
  </tbody>
</table>

- 改变后：
<table>
  <tbody>
    <tr>
      <th colspan="2">栈内存</th>
      <th>堆内存</th>
    </tr>
    <tr>
      <td>obj</td>
      <td>指针地址</td>
      <td>{ value: 1 }</td>
    </tr>
    <tr>
      <td>o</td>
      <td>2</td>
      <td></td>
    </tr>
  </tbody>
</table>

## 2. 手写 call 和 apply

### 2.1 手写 call

> call(): 在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法。

``` js
let foo = {
  value: 1
}

function bar() {
  console.log(this.value)
}

bar.call(foo)  // 1
```

注意亮点：
- call 改变了 this 的指向，指向到 foo
- bar 函数执行了

#### 2.1.1 第一步

上述方式等同于：
``` js
let foo = {
  value: 1,
  bar: function() {
    console.log(this.value)
  }
}
foo.bar()  // 1
```

这时候 `this` 就指向了 `foo` ，但是这样却给 `foo` 对象本身增加了一个属性，所以我们用 `delete` 再删除它即可。

所以我们模拟的步骤可以分为：
```
1. 将函数设为对象的属性
2. 执行该函数
3. 删除该函数
```

以上的例子为例，就是：
``` js
// fn 是对象的属性名，反正最后也是要删除掉的，因此起啥名字都可以
foo.fn = bar
foo.fn()
delete foo.fn
```

根据上述思路，提供一版：
``` js
Function.prototype.myCall = function(context) {
  // 首先要获取调用call的函数，用this可以获取
  context.fn = this
  context.fn()
  delete context.fn
}

// 测试
let foo = {
  value: 1
}
function bar() {
  console.log(this.value)
}
bar.myCall(foo)  // 1
```

#### 2.1.2 第二步

`call` 除了可以指定 `this`，还可以指定参数
``` js
let foo = {
  value: 1
}
function bar(name, age) {
  console.log(name)
  console.log(age)
  console.log(this.value)
}
bar.call(foo, 'kevin', 18) // kevin 18 1
```

可以从 `arguments` 对象中取值，取出第二个到最后一个参数，然后放到一个数组里。

上述代码的 `arguments` 中取第二个到最后一个的参数
``` js
// 以上面的例子为例，此时的arguments为：
// arguments = {
//   0: foo,
//   1: 'kevin',
//   2: 18,
//   length: 3
// }
// 因为 arguments 是类数组对象，所以可以用 for 循环
let args = []
for(let i = 1; i < arguments.length; i++) {
  args.push('arguments[' + i + ']')
}

// 执行后 args 为：["arguments[1]", "arguments[2]", "arguments[3]"]
```

接下来使用 `eval` 拼接成一个函数
``` js
eval('context.fn(' + args + ')')
```

考虑到目前大部分浏览器在 `console` 中限制了 `eval` 的使用，也可以使用 `rest` 来实现：
``` js
// 第二版
Function.prototype.myCall = function(context) {
  context.fn = this
  let args = [...arguments].slice(1)
  context.fn(...args)
  delete context.fn
}

// 测试
let foo = {
  value: 1
}

function bar(name, age) {
  console.log(name)
  console.log(age)
  console.log(this.value) // 1  
}

bar.myCall(foo, 'kevin', 18) // kevin 18 1
```

#### 2.1.3 第三步

1. this 参数可以传递 null，当为 null 的时候，视为指向 window

举个例子：
``` js
var value = 1;

function bar() {
  console.log(this.value);
}

bar.call(null); // 1
```

2. 针对函数，可以实现返回值

举个例子：
``` js
var foo = {
  value: 1
}

function bar(name, age) {
  return {
    value: this.value,
    name: name,
    age: age
  }
}

console.log(bar.call(foo, 'kevin', 18))
// {
//   value: 1,
//   name: 'kevin',
//   age: 18
// }
```

调整第二版代码：
``` js
// 第三版
Function.prototype.myCall = function(context) {
  var context = context || window
  context.fn = this

  let args = [...arguments].slice(1)
  let result = context.fn(...args)

  delete context.fn
  return result
}

// 测试
var value = 2

var obj = {
  value: 1
}

function bar(name, age) {
  console.log(this.value)
  return {
    value: this.value,
    name: name,
    age: age
  }
}

bar.myCall(null) // 2

console.log(bar.myCall(obj, 'kevin', 18))
// 1
// {
//   value: 1,
//   name: 'kevin',
//   age: 18
// }
```

最简化版的写法：
``` js
Function.prototype.myCall = function(context, ...args) {
  if(typeof context === undefined || context === null) {
    context = window
  }
  let fnSymbol = Symbol()
  context[fnSymbol] = this
  let result = context[fnSymbol](...args)
  delete context[fnSymbol]
  return result
}
```

### 2.2 手写 apply

`apply` 的实现跟 `call` 类似，只是传递的参数类型不同，`apply` 为数组。

``` js
Function.prototype.myApply = function(context, arr) {
  var context = Object(context) || window
  context.fn = this

  var result
  if (!arr) {
    result = context.fn()
  } else {
    result = context.fn(...arr)
  }

  delete context.fn
  return result
}
```

最简化版的写法：
``` js
Function.prototype.myApply = function(context, arr = []) {
  // 判断是否是 undefined 和 null
  if(typeof context === undefined || context === null) {
    context = window
  }

  let fnSymbol = Symbol()
  context[fnSymbol] = this
  let result = context[fnSymbol](...arr)

  delete context[fnSymbol]
  return result
}
```

